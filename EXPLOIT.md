Let's lay the foundations for what this document will explain.

First off: the Wii has two main processing units: 
- A PowerPC CPU, which is what Wii games actually run on. The PowerPC CPU runs no operating system, so games are written for bare-metal.
- An ARM CPU, also known as Starlet, which is responsible for security. It runs a micro-kernel architecture, and handles input/output devices on a subsystem known as IOS.

Typically, when a game is running, the Starlet CPU limits the privileges of the PowerPC CPU so that it cannot arbitrarily do things it does not need to.
One such limitation is managing installed titles, which are installed on the Wii's internal NAND flash memory. 

However, there are times when the PowerPC CPU may actually need access to various extra privileged subsystems. For example, the Wii System Menu may need to manage Wii settings,
as well as installed titles.
In order to control the privileges the PowerPC CPU has at any given moment, the Starlet CPU has a set of memory-mapped registers which it can manage in order to control what
actions can occur. In our case, the two registers of interest are [HW_SRNPROT] and [HW_AHBPROT].

The reason this is relevant is that there are a couple of cases in which we would like to do things the Starlet CPU would not normally let us do. In particular, we would like to be able to
manage the installation of the Retro Rewind channel in-app, and we also need to mess around with common keys if we are running the game from a Korean system 
(or using a Korean disc on a non-Korean system). All of these actions cannot be done normally, because the Starlet CPU won't let us.

Fortunately, the Starlet CPU also has an adjustment to decide which CPU(s) these privileges: this is what [HW_SRNPROT] controls. There is a bit in this register, AHPEN, which
defines whether the PowerPC CPU can manage the Wii's SRAM, which includes the registers used to set privileges. This is 0 (false) for any normal game title.

So, in order to be able to update the PowerPC CPU's privileges, we need to be able to directly program the Starlet CPU to do this. The Starlet CPU has never intended to run arbitrary code (for obvious
reasons: it is for secutiry after all) so how do we do it? This is where the exploit comes in.

The details of how the exploit works are not explained here (see https://wiibrew.org/wiki/Wii_system_flaws#IOS - specifically the /dev/sha exploit), but in essence, it enables us to run
arbitary code on the Starlet CPU. We will use this exploit to update the [HW_SRNPROT] and [HW_AHBPROT] registers to allow the PowerPC CPU to do everything we need it to do. After we are
done, we restore those registers to their original state, in order to minimise the time we have elevated privileges, thus reducing the risk of us causing damage with those privileges.

The sample implementation of the exploit this is based on is from [wfc-patcher-wii](https://github.com/WiiLink24/wfc-patcher-wii). Essentially, what we do is we write a small amount of
code to the start of MEM1 which branches to the exploit itself. This code at the start of MEM1 gets executed on the Starlet CPU by the wacky broken handling of zero-length vectors in /dev/sha.
The code which actually elevates the PowerPC CPU privileges is [here](https://github.com/WiiLink24/wfc-patcher-wii/blob/96147b536134937842a203c6033b3b370f4dcee7/launcher/source/IOS.cpp#L79-L86) - the rest of the assembly is essentially making sure all caches are up to date, and enabling the sending of synchronisation messages between the two CPUs.

The linked assembly is as follows, for convenience:
```assembly
mov     r2, #0x0D800000
ldr     r1, [r2, #0x60]
orr     r1, #0x08
str     r1, [r2, #0x60]
ldr     r1, [r2, #0x64]
orr     r1, #0x8000000E
orr     r1, #0x00000DF0
str     r1, [r2, #0x64]
```

The linked assembly works as follows:
- The first line of the assembly - `mov r2, #0x0D800000` - moves the base address of all memory-mapped registers to r2. There are many registers, most of which we don't care about - see
https://wiibrew.org/wiki/Hollywood/Registers. 
- The next line - `ldr r1, [r2, #0x60]` - loads the value of the memory address at r2+0x60 into r1, essentially, this loads the value of  [HW_SRNPROT] to r1, since the brackets indicate 
a dereference. 
- The third line - `orr r1, #0x08` - performs a logical OR (obviously). In [HW_SRNPROT], the bit at 0x08 is AHPEN, which "Enables PPC access to SRAM". So, if we enable this, it means that
we can now manage the registers directly from the PowerPC CPU moving forwards. We use this to easily reset these registers later to disable the elevated privileges (I think).
- The fourth line - `str r1, [r2, #0x60]` - stores the new [HW_SRNPROT] with the additional bit set back into the memory address at r2, which is the memory address of [HW_SRNPROT]. Now
we can manage the SRAM from the PowerPC CPU.
- The fifth line does the same thing as the second but it loads [HW_AHBPROT] into r2 instead.
- The next two lines set a bunch of bits in r1 to now be 1, which essentially enables everything for the PowerPC CPU in [HW_AHBPROT]. Then, the last line writes this new value to the register
memory mapped address again. There, all done.

All we now need to do is purge all the cache lines, synchronise the two CPUs again, and we're basically done. That's what the rest of the assembly is basically doing.

[HW_SRNPROT]: https://wiibrew.org/wiki/Hollywood/Registers#HW_SRNPROT
[HW_AHBPROT]: https://wiibrew.org/wiki/Hollywood/Registers#HW_AHBPROT